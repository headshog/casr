diff --git a/casr/src/bin/casr-afl.rs b/casr/src/bin/casr-afl.rs
index 5e98fa6..81d9269 100644
--- a/casr/src/bin/casr-afl.rs
+++ b/casr/src/bin/casr-afl.rs
@@ -1,13 +1,13 @@
 use casr::triage::{fuzzing_crash_triage_pipeline, CrashInfo};
 use casr::util;
 
+use anyhow::bail;
 use anyhow::Result;
 use clap::{
     error::{ContextKind, ContextValue, ErrorKind},
     Arg, ArgAction,
 };
 use log::error;
-use anyhow::bail;
 
 use std::collections::HashMap;
 use std::fs;
@@ -132,20 +132,17 @@ fn main() -> Result<()> {
     };
 
     let at_index = if gdb_args.is_empty() {
-        print!("here {:?}\n", argv);
         if let Some(idx) = argv.iter().skip(1).position(|s| s.contains("@@")) {
             Some(idx + 1)
         } else {
             argv.push("@@");
             Some(argv.len() - 1)
         }
+    } else if !argv.is_empty() && argv[0] == "@@" {
+        gdb_args.push("@@".to_string());
+        Some(gdb_args.len() - 1)
     } else {
-        if !argv.is_empty() && argv[0] == "@@" {
-            gdb_args.push("@@".to_string());
-            Some(gdb_args.len() - 1)
-        } else {
-            None
-        }
+        None
     };
 
     // Get tool.
@@ -193,7 +190,7 @@ fn main() -> Result<()> {
                 ]
                 .into_iter()
                 .collect(),
-                at_index: at_index,
+                at_index,
                 ..Default::default()
             }
         };
diff --git a/casr/src/bin/casr-csharp.rs b/casr/src/bin/casr-csharp.rs
index 516497e..d467929 100644
--- a/casr/src/bin/casr-csharp.rs
+++ b/casr/src/bin/casr-csharp.rs
@@ -105,10 +105,10 @@ fn main() -> Result<()> {
     // Set executable path (for C# .dll (dotnet) or .exe (mono) file)
     if let Some(pos) = argv
         .iter()
-        .position(|x| x.ends_with(".dll") || x.ends_with(".exe"))
+        .position(|x| x.ends_with(".dll") || x.ends_with(".exe") || x.ends_with(".csproj"))
     {
         let Some(classes) = argv.get(pos) else {
-            bail!("dotnet target is not specified by .dll executable.");
+            bail!("dotnet target is not specified by .dll, .exe or .csproj executable.");
         };
         report.executable_path = classes.to_string();
     }
diff --git a/casr/tests/casr_tests/csharp/test_casr_csharp.cs b/casr/tests/casr_tests/csharp/test_casr_csharp.cs
new file mode 100644
index 0000000..9ff4fa3
--- /dev/null
+++ b/casr/tests/casr_tests/csharp/test_casr_csharp.cs
@@ -0,0 +1,17 @@
+﻿using System;
+
+public class Program
+{
+  public static void Main(string[] args)
+  {
+    f1();
+  }
+  
+  public static void f1() {
+    f2();
+  }
+
+  public static void f2() {
+    throw new ArgumentException("Parameter cannot be null");
+  }
+}
diff --git a/casr/tests/casr_tests/csharp/test_casr_csharp.csproj b/casr/tests/casr_tests/csharp/test_casr_csharp.csproj
new file mode 100644
index 0000000..206b89a
--- /dev/null
+++ b/casr/tests/casr_tests/csharp/test_casr_csharp.csproj
@@ -0,0 +1,10 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFramework>net8.0</TargetFramework>
+    <ImplicitUsings>enable</ImplicitUsings>
+    <Nullable>enable</Nullable>
+  </PropertyGroup>
+
+</Project>
diff --git a/casr/tests/tests.rs b/casr/tests/tests.rs
index 0a16fe5..c4c4047 100644
--- a/casr/tests/tests.rs
+++ b/casr/tests/tests.rs
@@ -22,6 +22,7 @@ lazy_static::lazy_static! {
     static ref EXE_CASR_PYTHON: RwLock<&'static str> = RwLock::new(env!("CARGO_BIN_EXE_casr-python"));
     static ref EXE_CASR_JAVA: RwLock<&'static str> = RwLock::new(env!("CARGO_BIN_EXE_casr-java"));
     static ref EXE_CASR_JS: RwLock<&'static str> = RwLock::new(env!("CARGO_BIN_EXE_casr-js"));
+    static ref EXE_CASR_CSHARP: RwLock<&'static str> = RwLock::new(env!("CARGO_BIN_EXE_casr-csharp"));
     static ref EXE_CASR_GDB: RwLock<&'static str> = RwLock::new(env!("CARGO_BIN_EXE_casr-gdb"));
     static ref PROJECT_DIR: RwLock<&'static str> = RwLock::new(env!("CARGO_MANIFEST_DIR"));
 }
@@ -5705,3 +5706,183 @@ fn test_casr_libfuzzer_jazzer_js_xml2js() {
 
     assert!(storage.values().all(|x| *x > 1));
 }
+
+#[test]
+#[cfg(target_arch = "x86_64")]
+fn test_casr_csharp() {
+    let paths = [
+        abs_path("tests/casr_tests/csharp/test_casr_csharp.cs"),
+        abs_path("tests/casr_tests/csharp/test_casr_csharp.csproj"),
+        abs_path("tests/tmp_tests_casr/test_casr_csharp"),
+        abs_path("tests/tmp_tests_casr/test_casr_csharp/test_casr_csharp.cs"),
+        abs_path("tests/tmp_tests_casr/test_casr_csharp/test_casr_csharp.csproj"),
+    ];
+    let _ = std::fs::create_dir_all(&paths[2]);
+    let _ = fs::copy(&paths[0], &paths[3]);
+    let _ = fs::copy(&paths[1], &paths[4]);
+    let Ok(dotnet_path) = which::which("dotnet") else {
+        panic!("No dotnet is found.");
+    };
+
+    let output = Command::new(*EXE_CASR_CSHARP.read().unwrap())
+        .args([
+            "--stdout",
+            "--",
+            &dotnet_path.to_str().unwrap(),
+            "run",
+            "--project",
+            &paths[4],
+        ])
+        .output()
+        .expect("failed to start casr-csharp");
+
+    assert!(
+        output.status.success(),
+        "Stdout {}.\n Stderr: {}",
+        String::from_utf8_lossy(&output.stdout),
+        String::from_utf8_lossy(&output.stderr)
+    );
+
+    let report: Result<Value, _> = serde_json::from_slice(&output.stdout);
+    if let Ok(report) = report {
+        let severity_type = report["CrashSeverity"]["Type"].as_str().unwrap();
+        let severity_desc = report["CrashSeverity"]["ShortDescription"]
+            .as_str()
+            .unwrap()
+            .to_string();
+
+        assert_eq!(3, report["Stacktrace"].as_array().unwrap().iter().count());
+        assert_eq!(severity_type, "UNDEFINED");
+        assert_eq!(severity_desc, "System.ArgumentException");
+        assert!(report["CrashLine"]
+            .as_str()
+            .unwrap()
+            .contains("test_casr_csharp.cs:15"));
+    } else {
+        panic!("Couldn't parse json report file.");
+    }
+}
+
+#[test]
+#[cfg(target_arch = "x86_64")]
+fn test_casr_afl_csharp() {
+    /*use std::collections::HashMap;
+
+    let test_dir = abs_path("tests/tmp_tests_casr/test_casr_libfuzzer_jazzer_js");
+    let _ = std::fs::remove_dir_all(test_dir);
+    let paths = [
+        abs_path("tests/casr_tests/js/test_casr_libfuzzer_jazzer_js.js"),
+        abs_path("tests/tmp_tests_casr/test_casr_libfuzzer_jazzer_js/crashes"),
+        abs_path("tests/tmp_tests_casr/test_casr_libfuzzer_jazzer_js/casr_out"),
+        abs_path(
+            "tests/tmp_tests_casr/test_casr_libfuzzer_jazzer_js/test_casr_libfuzzer_jazzer_js.js",
+        ),
+    ];
+
+    // Create crashes dir
+    let output = Command::new("mkdir")
+        .args(["-p", &paths[1]])
+        .output()
+        .expect("failed to create dir");
+    assert!(
+        output.status.success(),
+        "Stdout {}.\n Stderr: {}",
+        String::from_utf8_lossy(&output.stdout),
+        String::from_utf8_lossy(&output.stderr)
+    );
+
+    let _ = fs::copy(&paths[0], &paths[3]);
+
+    let Ok(npx_path) = which::which("npx") else {
+        panic!("No npx is found.");
+    };
+
+    Command::new("unzip")
+        .arg(abs_path("tests/casr_tests/js/crashes.zip"))
+        .args(["-d", &paths[1]])
+        .stdout(Stdio::null())
+        .status()
+        .expect("failed to unzip crashes.zip");
+
+    let bins = Path::new(*EXE_CASR_LIBFUZZER.read().unwrap())
+        .parent()
+        .unwrap();
+    let mut cmd = Command::new(*EXE_CASR_LIBFUZZER.read().unwrap());
+    cmd.args([
+        "-i",
+        &paths[1],
+        "-o",
+        &paths[2],
+        "--",
+        npx_path.to_str().unwrap(),
+        "jazzer",
+        &paths[3],
+    ])
+    .env(
+        "PATH",
+        format!("{}:{}", bins.display(), std::env::var("PATH").unwrap()),
+    );
+    let output = cmd.output().expect("failed to start casr-libfuzzer");
+
+    assert!(
+        output.status.success(),
+        "Stdout {}.\n Stderr: {}",
+        String::from_utf8_lossy(&output.stdout),
+        String::from_utf8_lossy(&output.stderr)
+    );
+    let err = String::from_utf8_lossy(&output.stderr);
+
+    assert!(!err.is_empty());
+
+    assert!(err.contains("NOT_EXPLOITABLE"));
+    assert!(err.contains("TypeError"));
+    assert!(err.contains("ReferenceError"));
+    assert!(err.contains("RangeError"));
+    assert!(err.contains("test_casr_libfuzzer_jazzer_js.js"));
+
+    let re = Regex::new(r"Number of reports after deduplication: (?P<unique>\d+)").unwrap();
+    let unique_cnt = re
+        .captures(&err)
+        .unwrap()
+        .name("unique")
+        .map(|x| x.as_str())
+        .unwrap()
+        .parse::<u32>()
+        .unwrap();
+
+    assert_eq!(unique_cnt, 3, "Invalid number of deduplicated reports");
+
+    let re = Regex::new(r"Number of clusters: (?P<clusters>\d+)").unwrap();
+    let clusters_cnt = re
+        .captures(&err)
+        .unwrap()
+        .name("clusters")
+        .map(|x| x.as_str())
+        .unwrap()
+        .parse::<u32>()
+        .unwrap();
+
+    assert_eq!(clusters_cnt, 1, "Invalid number of clusters");
+
+    let mut storage: HashMap<String, u32> = HashMap::new();
+    for entry in fs::read_dir(&paths[2]).unwrap() {
+        let e = entry.unwrap().path();
+        let fname = e.file_name().unwrap().to_str().unwrap();
+        if fname.starts_with("cl") && e.is_dir() {
+            for file in fs::read_dir(e).unwrap() {
+                let mut e = file.unwrap().path();
+                if e.is_file() && e.extension().is_some() && e.extension().unwrap() == "casrep" {
+                    e = e.with_extension("");
+                }
+                let fname = e.file_name().unwrap().to_str().unwrap();
+                if let Some(v) = storage.get_mut(fname) {
+                    *v += 1;
+                } else {
+                    storage.insert(fname.to_string(), 1);
+                }
+            }
+        }
+    }
+
+    assert!(storage.values().all(|x| *x > 1));*/
+}
diff --git a/libcasr/src/execution_class.rs b/libcasr/src/execution_class.rs
index ab69db5..91f6e76 100644
--- a/libcasr/src/execution_class.rs
+++ b/libcasr/src/execution_class.rs
@@ -204,7 +204,7 @@ impl Default for ExecutionClass {
             severity: "UNDEFINED".to_string(),
             short_description: "Undefined".to_string(),
             description: "Undefined class".to_string(),
-            explanation: "The is no execution class for this type of exception".to_string(),
+            explanation: "There is no execution class for this type of exception".to_string(),
         }
     }
 }
